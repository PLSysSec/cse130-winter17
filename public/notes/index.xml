<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes-rsses on CSE 130</title>
    <link>https://cseweb.ucsd.edu/~dstefan/cse130-winter17/notes/index.xml</link>
    <description>Recent content in Notes-rsses on CSE 130</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>deian&#43;cse130@cs.ucsd.edu (Deian Stefan)</managingEditor>
    <webMaster>deian&#43;cse130@cs.ucsd.edu (Deian Stefan)</webMaster>
    <lastBuildDate>Mon, 09 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://cseweb.ucsd.edu/~dstefan/cse130-winter17/notes/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The power of JavaScript first-class functions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse130-winter17/notes/intro-js-code/</link>
      <pubDate>Mon, 09 Jan 2017 00:00:00 +0000</pubDate>
      <author>deian&#43;cse130@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse130-winter17/notes/intro-js-code/</guid>
      <description>

&lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css&#34;&gt;
&lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js&#34;&gt;&lt;/script&gt;


&lt;h3 id=&#34;block-scoping-with-functions&#34;&gt;Block scoping with functions:&lt;/h3&gt;

&lt;p&gt;Modern JavaScript has block scoping when using &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; binders:&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;scope-modern&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;scope-modern&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
function hello(x) {
  console.log(`A: x = ${x}`); // ??
  {
    const x = 45;
    console.log(`B: x = ${x}`); // ??
  }
  {
    console.log(`C: x = ${x}`); // ??
  }
}
hello(42);

&lt;/div&gt;


&lt;p&gt;This is not true for &lt;code&gt;var&lt;/code&gt; binders, which are scoped to the nearest function scope (if one exists, otherwise, the global scope):&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;scope-var&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;scope-var&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
function hello(x) {
  console.log(`A: x = ${x}`); // ??
  {
    var x = 45;
    console.log(`B: x = ${x}`); // ??
  }
  {
    console.log(`C: x = ${x}`); // ??
  }
}

hello(42);

&lt;/div&gt;


&lt;p&gt;We can, however, introdue block scoping to code that only uses &lt;code&gt;var&lt;/code&gt;
declarations by using first-class functions to create a new function scope:&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;scope-modernize-var&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;scope-modernize-var&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
function hello(x) {
  console.log(`A: x = ${x}`); // ??
  (function () {
    var x = 45;
    console.log(`B: x = ${x}`); // ??
  })();
  (function () {
    console.log(`C: x = ${x}`); // ??
  })();
}

hello(42);

&lt;/div&gt;


&lt;p&gt;Rather than use the verbose &lt;code&gt;function&lt;/code&gt; declarations, we can also write anonymous functions using the fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;), as such:&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;scope-modernize-var-pretty&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;scope-modernize-var-pretty&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
function hello(x) {
  console.log(`A: x = ${x}`); // ??
  (() =&gt; {
    var x = 45;
    console.log(`B: x = ${x}`); // ??
  })();
  (() =&gt; {
    console.log(`C: x = ${x}`); // ??
  })();
}

hello(42);

&lt;/div&gt;


&lt;h2 id=&#34;callbacks-for-performing-concurrent-asynchronous-filesystem-reads&#34;&gt;Callbacks for performing concurrent, asynchronous filesystem reads:&lt;/h2&gt;

&lt;p&gt;Node.js ships with a code JavaScript library that can be used to read and write files.
Node.js exposes functions for reading (writing) files synchronously:&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;perf-sync&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;perf-sync&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
const fs = require(&#39;fs&#39;);

prepFiles(); // ignore, this we&#39;re just calling this function to populate filesystem

const r1 = fs.readFileSync(&#39;./a.txt&#39;, &#39;utf8&#39;); // blocks until read is done
processFile(&#39;a.txt&#39;, r1); //blocks until processing (write) is done
const r2 = fs.readFileSync(&#39;./b.txt&#39;, &#39;utf8&#39;); // etc.
processFile(&#39;b.txt&#39;, r2);

// note that you can declare a function after the point it&#39;s used. Hoisting
// essentially moves it to the top.
function processFile(fname, str) {
  fs.writeFileSync(`/tmp/${fname}`, str);
  console.log(`DONE writing /tmp/${fname}`);
}

function prepFiles() {
	// our examples read these two files, let&#39;s make sure that they exist on the runkit machine
  fs.writeFileSync(&#39;./a.txt&#39;, &#39;alice!&#39;);
  fs.writeFileSync(&#39;./b.txt&#39;, &#39;bob!&#39;);
}

&lt;/div&gt;


&lt;p&gt;Note that each of the reads and writes block, waiting for the files to be read and processed. But this need not be the case. We can leverage the fact that the underling runtime and OS have concurrency and we can read the files concurrently:
&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;perf-async&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;perf-async&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
const fs = require(&#39;fs&#39;);

prepFiles(); // ignore, this we&#39;re just calling this function to populate filesystem

fs.readFile(&#39;./a.txt&#39;, &#39;utf8&#39;, cb1); // returns immediately, cb1 is queued on the event loop and called later when actual file read is done
fs.readFile(&#39;./b.txt&#39;, &#39;utf8&#39;, cb2); // returns immediately, &#34; &#34;

function processFile(fname, str) {
  fs.writeFileSync(`/tmp/${fname}`, str);
  console.log(`DONE writing /tmp/${fname}`);
}

function cb1(err, str) {
  processFile(&#39;a.txt&#39;, str);
}

function cb2(err, str) {
  processFile(&#39;b.txt&#39;, str);
}

function prepFiles() {
	// our examples read these two files, let&#39;s make sure that they exist on the runkit machine
  fs.writeFileSync(&#39;./a.txt&#39;, &#39;alice!&#39;);
  fs.writeFileSync(&#39;./b.txt&#39;, &#39;bob!&#39;);
}

&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The above code tells the Node.js runtime to read the file &lt;code&gt;a,txt&lt;/code&gt;, without
blocking, and call function &lt;code&gt;cb1&lt;/code&gt; with the error condition and data once it
read the file (or failed). Note that JavaScript always runs code to completion for each &lt;em&gt;event loop&lt;/em&gt;.
In the first event loop we tell the runtime to read files, and the runtime, in later event loops, will call our callback functions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Challenge:&lt;/strong&gt; further modify this code to eliminate the synchronous writes.&lt;/p&gt;

&lt;p&gt;Since JavaScript has first-class functions, we can clean up the above code and move the repeated code into processFie (which now returns a function that is pased to &lt;code&gt;readFile&lt;/code&gt;):
&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;perf-async-2&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;perf-async-2&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
const fs = require(&#39;fs&#39;);
prepFiles();

fs.readFile(&#39;./a.txt&#39;, &#39;utf8&#39;, processFile(&#39;a.txt&#39;));
fs.readFile(&#39;./b.txt&#39;, &#39;utf8&#39;, processFile(&#39;b.txt&#39;));


function processFile(fname) {
  return (err, str) =&gt; {
    fs.writeFileSync(`/tmp/${fname}`, str);
    console.log(`DONE writing /tmp/${fname}`);
  };
}

function prepFiles() {
	// our examples read these two files, let&#39;s make sure that they exist on the runkit machine
  fs.writeFileSync(&#39;./a.txt&#39;, &#39;alice!&#39;);
  fs.writeFileSync(&#39;./b.txt&#39;, &#39;bob!&#39;);
}

&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Indeed, we can go a step further and remove other redudent code:&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;perf-async-3&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;perf-async-3&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
const fs = require(&#39;fs&#39;);

prepFiles();

readAndProcessFile(&#39;a.txt&#39;);
readAndProcessFile(&#39;b.txt&#39;);

function readAndProcessFile(name) {
  return fs.readFile(`./${name}`, &#39;utf8&#39;, processFile(name));
}

function processFile(fname) {
  return (err, str) =&gt; {
    fs.writeFileSync(`/tmp/${fname}`, str);
    console.log(`DONE writing /tmp/${fname}`);
  };
}

function prepFiles() {
	// our examples read these two files, let&#39;s make sure that they exist on the runkit machine
  fs.writeFileSync(&#39;./a.txt&#39;, &#39;alice!&#39;);
  fs.writeFileSync(&#39;./b.txt&#39;, &#39;bob!&#39;);
}

&lt;/div&gt;


&lt;h2 id=&#34;high-order-functions-and-closures&#34;&gt;High order functions and closures:&lt;/h2&gt;

&lt;p&gt;With first-class functions, we can write clean, declarative (functional) code.
We don&amp;rsquo;t have to write code that tells the computer what to do, but rather have
the code more closely resemble what we mean (mathematically). For example, we
can process lists as such:&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;expressive&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;expressive&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
const list = [1, 2, 3, 4];

console.log(filter(list, function (el) { 
  return el &gt; 2;
})); // ??

console.log(map(list, el =&gt; { 
  return el + 42;
})); // ??


function filter(list, pred) {
  const dup = [];
  for (let i = 0; i &lt; list.length; i++) {
    if (pred(list[i])) {
      dup.push(list[i]);
    }
  }
  return dup;
}

function map(list, f) {
  const dup = [];
  for (let i = list.length-1; i &gt;= 0; i--) {
    dup.unshift(f(list[i]));
  }
  return dup;
}

&lt;/div&gt;


&lt;p&gt;Since functions are first-class, we can even define function composition - a
high-order function that takes functions as arguments and returns their
composition. This is for example, useful if we want to apply several functions
over each element of a list:&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;hof&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;hof&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
const list = [1, 2, 3, 4];

const add42 = (el) =&gt; {
  return el + 42;
};

const mul1337 = (el) =&gt; {
  return el * 1337;
};

console.log(map(map(list, add42), mul1337));
console.log(map(list, compose(mul1337, add42)));

function compose(f, g) {
  return (x) =&gt; {
    return f(g(x));
  };
}

function map(list, f) {
  const dup = [];
  for (let i = list.length-1; i &gt;= 0; i--) {
    dup.unshift(f(list[i]));
  }
  return dup;
}

&lt;/div&gt;


&lt;p&gt;It&amp;rsquo;s important to understand that JavaScript functions are &lt;strong&gt;not&lt;/strong&gt; just function-pointers. They are closures. That is, a pair encoding the function code and the enclosing environment:&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;closure&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;closure&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
/* recall our definition:
const add42 = (el) =&gt; {
  return el + 42;
};
*/

function makeAddFunc(offset) {
  return (x) =&gt; {
    return offset + x; // note offset is captured here
  };
}

const add42 = makeAddFunc(42);
const sub42 = makeAddFunc(-42);

console.log(add42(1)); // ??
console.log(add42(42)); // ??

console.log(sub42(1)); // ??
console.log(sub42(42)); // ??


// Note the environment:

function f(x) {
  let y = x;
  return function (z) {
    y += z;
    return y;
  };
}

const h = f(5);
console.log(h(3)); // ??

&lt;/div&gt;


&lt;h2 id=&#34;using-functions-to-implement-modules&#34;&gt;Using functions to implement modules:&lt;/h2&gt;

&lt;p&gt;First-class functions are incredibly powerful. We can even use them to
implement modules. For example, below we define a simple module &lt;code&gt;myModule&lt;/code&gt;, which like Node.js modules contains an &lt;code&gt;exports&lt;/code&gt; object in scope that is, in turn, used to define the module interface.  This module is loaded by calling &lt;code&gt;requireMyModule&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;https://embed.runkit.com&#34; data-element-id=&#34;module&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;module&#34; nodeVersion=&#34;6.9.2&#34;&gt;
  
// using our fake require:
{
  const mod = requireMyModule();

  console.log(mod.myVar); // ??
  mod.myFunc(&#34;what?&#34;); // ??
  mod.myFunc(&#34;cse130 is fun!&#34;); // ??
}

function myModule(exports) {
  const secret = &#34;cse130 is fun!&#34;;
  exports.myVar = 42;
  exports.myFunc = function (x) {
    if (x === secret) {
      console.log(&#39;yes!&#39;);
    } else {
      console.log(&#39;guess again!&#39;);
    }
  };
}

function requireMyModule() {
  // create new object that will be populated by the module
  const exports = {};
  myModule(exports);
  return exports;
}

&lt;/div&gt;


&lt;p&gt;Node modules are slightly more complicated, but not that much more! They
basically take the contents of a file, wrap it as if the module was a function
(with &lt;code&gt;&amp;quot;function (exports ) {&amp;quot;&lt;/code&gt; et.c) and then &lt;code&gt;eval&lt;/code&gt; it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Intro and JavaScript</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse130-winter17/notes/intro-js/</link>
      <pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate>
      <author>deian&#43;cse130@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse130-winter17/notes/intro-js/</guid>
      <description>

&lt;h3 id=&#34;lecture-slides-and-code&#34;&gt;Lecture slides and code&lt;/h3&gt;

&lt;p&gt;You can get the slides &lt;a href=&#34;../../slides/js-nutshell.pdf&#34;&gt;here&lt;/a&gt;. The
slides refer to some JavaScript files, provided below. You can also play with this code in your browser &lt;a href=&#34;../intro-js-code&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;recommended-reading&#34;&gt;Recommended reading&lt;/h3&gt;

&lt;p&gt;If you have not worked with JavaScript before, take some time to familiarize
yourself with the basics of the language, as most of the labs in this class
will be in JavaScript.&lt;/p&gt;

&lt;p&gt;We recommend the &lt;a
href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&#34;&gt;Mozilla
Developer Network&amp;rsquo;s JavaScript Guide&lt;/a&gt;,
but there are many other tutorials on the Internet.&lt;/p&gt;

&lt;p&gt;Dave Herman&amp;rsquo;s &lt;a href=&#34;http://effectivejs.com/&#34;&gt;Effective JavaScript&lt;/a&gt; is
very good reference that covers a lot of the JavaScript intricacies.  You will
not this for the class, but if you end up writing JavaScript code in the
outside world, this book is must-read.&lt;/p&gt;

&lt;h3 id=&#34;additional-resources-reading-for-the-curious&#34;&gt;Additional resources/reading for the curious&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leanpub.com/understandinges6/read#leanpub-auto-block-bindings&#34;&gt;Block bindings&lt;/a&gt; and the difference between &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, and &lt;code&gt;const&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Why a language like JavaScript took over the world? Not that uncommon, see &lt;a href=&#34;https://www.jwz.org/doc/worse-is-better.html&#34;&gt;The Rise of &amp;ldquo;Worse is Better&amp;rdquo;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&#34;&gt;Closures&lt;/a&gt; explained; see, especially the creating closures in a loop section.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://curiosity-driven.org/private-properties-in-javascript&#34;&gt;Private properties in (modern) JavaScript&lt;/a&gt;; we will revisit the idea of private properties (encapsulation) later in the course.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management&#34;&gt;Short intro to memory management for JavaScript&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/category/es6-in-depth/&#34;&gt;ES6 In Depth Articles&lt;/a&gt; contains more information on the more recent features introduced to JavaScript.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;source-files-we-used-in-class&#34;&gt;Source files we used in class&lt;/h3&gt;

&lt;p&gt;Code illustrating how to implement block scoping with functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/scope-modern.js&#34;&gt;scope-modern.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/scope-var.js&#34;&gt;scope-var.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/scope-modernize-var.js&#34;&gt;scope-modernize-var.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/scope-modernize-var-pretty.js&#34;&gt;scope-modernize-var-pretty.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code illustrating the use of callback to perform synchronous and asynchronous
filesystem reads:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/perf-sync.js&#34;&gt;perf-sync.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/perf-async.js&#34;&gt;perf-async.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/perf-async-2.js&#34;&gt;perf-async-2.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/perf-async-3.js&#34;&gt;perf-async-3.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code illustrating the use of high order functions and closures:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/expressive.js&#34;&gt;expressive.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/hof.js&#34;&gt;hof.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/closure.js&#34;&gt;closure.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code illustrating the use of functions to implement modules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/module-node.js&#34;&gt;module-node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/module.js&#34;&gt;module.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code illustrating simple methods and constructors for JavaScript:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/receiver.js&#34;&gt;receiver.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../code/intro-js/class.js&#34;&gt;class.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
